#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Flattens the CodinGame2026 multi-file project into a single Program.cs
    ready for copy-paste into the CodinGame editor.

.DESCRIPTION
    Collects every .cs file under src/CodinGame2026/, strips duplicate 'using'
    directives, removes file-scoped namespace declarations, and concatenates the
    result into tools/output/Program.cs.

.EXAMPLE
    pwsh ./tools/merge.ps1
    # Output: tools/output/Program.cs
#>

[CmdletBinding()]
param (
    [string] $SourceDir = "$PSScriptRoot/../src/CodinGame2026",
    [string] $OutputDir = "$PSScriptRoot/output",
    [string] $OutputFile = "Program.cs"
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# ── Resolve paths ────────────────────────────────────────────────────────────

$SourceDir  = Resolve-Path $SourceDir
$OutputPath = Join-Path $OutputDir $OutputFile

if (-not (Test-Path $OutputDir)) {
    New-Item -ItemType Directory -Path $OutputDir | Out-Null
}

# ── Collect source files ─────────────────────────────────────────────────────

# Process Program.cs last so top-level statements come at the end of the file.
$allFiles = Get-ChildItem -Path $SourceDir -Filter '*.cs' -Recurse |
    Where-Object { $_.Name -ne 'Program.cs' } |
    Sort-Object FullName

$programCs = Get-ChildItem -Path $SourceDir -Filter 'Program.cs' -Recurse |
    Select-Object -First 1

if ($programCs) { $allFiles = @($allFiles) + @($programCs) }

Write-Host "Found $($allFiles.Count) .cs file(s)." -ForegroundColor Cyan

# ── Process files ────────────────────────────────────────────────────────────

$globalUsings = [System.Collections.Generic.SortedSet[string]]::new()
$bodyBlocks   = [System.Collections.Generic.List[string]]::new()

foreach ($file in $allFiles) {
    $lines  = Get-Content $file.FullName
    $usings = [System.Collections.Generic.List[string]]::new()
    $body   = [System.Collections.Generic.List[string]]::new()

    foreach ($line in $lines) {
        if ($line -match '^\s*using\s+\S') {
            # Strip file-scoped namespace "using Foo;" directives — keep them as global usings
            $usings.Add($line.Trim())
        } elseif ($line -match '^\s*namespace\s+\S+\s*;') {
            # File-scoped namespace declaration — drop it (we'll be in global scope)
        } else {
            $body.Add($line)
        }
    }

    foreach ($u in $usings) { $globalUsings.Add($u) | Out-Null }

    # Trim trailing blank lines from the block, then add a separator comment
    $trimmed = ($body | Select-String -Pattern '\S' -List -Raw | Select-Object -Last 1)
    $lastIdx = $body.LastIndexOf($trimmed)
    if ($lastIdx -ge 0) {
        $bodySlice = $body[0..$lastIdx]
    } else {
        $bodySlice = @()
    }

    if ($bodySlice.Count -gt 0) {
        $rel = $file.FullName.Substring($SourceDir.Path.Length + 1).Replace('\', '/')
        $bodyBlocks.Add("// ── $rel ──")
        $bodyBlocks.AddRange($bodySlice)
        $bodyBlocks.Add('')
    }
}

# ── Write output ─────────────────────────────────────────────────────────────

$output = [System.Text.StringBuilder]::new()

$output.AppendLine("// Auto-generated by tools/merge.ps1 — $(Get-Date -Format 'yyyy-MM-dd HH:mm')")
$output.AppendLine("// Do NOT edit this file manually — edit the source files instead.")
$output.AppendLine()

foreach ($u in $globalUsings) {
    $output.AppendLine($u)
}
$output.AppendLine()

foreach ($block in $bodyBlocks) {
    $output.AppendLine($block)
}

[System.IO.File]::WriteAllText($OutputPath, $output.ToString(), [System.Text.Encoding]::UTF8)

Write-Host "Merged output written to: $OutputPath" -ForegroundColor Green
Write-Host "Lines: $($output.ToString().Split([Environment]::NewLine).Count)" -ForegroundColor Green
